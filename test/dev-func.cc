//
// Copyright Axel Zeuner 2010-2017. Use, modification and
// distribution is subject to the Boost Software License, Version
// 1.0. (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#include "cftal/vec.h"
#include "cftal/vec_traits.h"
#include "cftal/math/elem_func.h"
#include "cftal/math/elem_func_core_f64.h"
#include "cftal/math/elem_func_core_f32.h"
#include "cftal/test/of_math_funcs.h"
#include "cftal/test/check_expm1.h"
#include <tuple>
#include <iostream>
#include <iomanip>
#include <memory>

#define EXP 1

namespace cftal {

    namespace math {
        template <typename _FLOAT_T, typename _TRAITS_T>
        struct test_func : public elem_func_core< _FLOAT_T, _TRAITS_T> {
            using base_type = elem_func_core<_FLOAT_T, _TRAITS_T>;
            using my_type = test_func<_FLOAT_T, _TRAITS_T>;
            using vf_type = typename base_type::vf_type;
            using vi_type = typename base_type::vi_type;
            using vmf_type = typename base_type::vmf_type;
            using vmi_type = typename base_type::vmi_type;
            using dvf_type = typename base_type::dvf_type;

            static vf_type func(arg_t<vf_type> vf);
        };

        template <typename _T>
        struct test_func<double, _T> : public elem_func_core<double, _T> {
            using base_type = elem_func_core<double, _T>;
            using vf_type = typename _T::vf_type;
            using vi_type = typename _T::vi_type;
            // using vli_type = typename _T::vli_type;
            using vi2_type = typename _T::vi2_type;
            using vmf_type = typename _T::vmf_type;
            using vmi_type = typename _T::vmi_type;
            using vmi2_type = typename _T::vmi2_type;

            using dvf_type = d_real<vf_type>;
            using tvf_type = t_real<vf_type>;
            using my_type = test_func<double, _T>;

            using d_ops = typename base_type::d_ops;

            // static vf_type func_k(arg_t<vf_type> vf);

            using base_type::ilogbp1_k;
            using base_type::ldexp_k;

        };

        template <typename _T>
        struct test_func<float, _T> : public elem_func_core<float, _T> {
            using base_type = elem_func_core<float, _T>;
            using vf_type = typename _T::vf_type;
            using vi_type = typename _T::vi_type;
            // using vli_type = typename _T::vli_type;
            using vmf_type = typename _T::vmf_type;
            using vmi_type = typename _T::vmi_type;

            using dvf_type = d_real<vf_type>;
            using tvf_type = t_real<vf_type>;
            using my_type = test_func<float, _T>;

            using d_ops = typename base_type::d_ops;

            static vf_type func(arg_t<vf_type> vf);
            static vf_type func_k(arg_t<vf_type> vf);

            using base_type::ilogbp1;
            using base_type::ldexp;
            using base_type::__reduce_exp_arg;
            using base_type::__scale_exp_k;
            using base_type::__exp_k;
        };


    }

    namespace test {

        template <typename _T>
        struct check_func {
            template <std::size_t _N>
            static
            vec<_T, _N>
            v(const vec<_T, _N>& a) {
                using traits_t=math::func_traits<vec<_T, _N>,
                                                 vec<int32_t, _N> >;
                using func_t=math::test_func<_T, traits_t>;
                return func_t::func(a);
            }
            static
            auto
            r(const _T& a) {
                std::pair<_T, _T> i;
#if EXP>0
                _T v=call_mpfr::func(a, mpfr_exp, &i);
#else
                _T v=call_mpfr::func(a, mpfr_expm1, &i);
#endif
                return std::make_tuple(v, i.first, i.second);
            }
            static
            _T
            s(const _T& a) {
#if EXP>0
                return std::expm1(a);
#else
                return std::expm1(a);
#endif
            }
            static
            const char* fname() { return "func"; }
        };



    }
}

template <typename _T>
inline
typename cftal::math::test_func<float, _T>::vf_type
cftal::math::test_func<float, _T>::func_k(arg_t<vf_type> xc)
{
    vf_type xrh, xrl, kf;
    auto k= __reduce_exp_arg(xrh, xrl, kf, xc);
#if EXP> 0
    // exp(x) = 1 + 2x/(2-x+x^2*P(x^2)
    //                    x [x - x^2 * P]
    //        = 1 + x + ------------------
    //                    2 - [x - x^2 * P]
    // [0, 0.3465735912322998046875] : | p - f | <= 2^-22.984375
    // coefficients for native_exp generated by sollya
    // x^0 : +0xa.aaaa3p-6f
    const float native_exp_c0=+1.6666655242e-01f;
    // x^2 : -0xb.58753p-12f
    const float native_exp_c2=-2.7699067723e-03f;
    vf_type xx= xrh*xrh;
    vf_type y = xrl + xrl*xrh;
    vf_type P= impl::poly(xx,
                          native_exp_c2,
                          native_exp_c0);
    vf_type br= xrh- xx*P;
    y += (xrh*br)/(2.0f-br);
    y += xrh;
    y += 1.0f;
    y = __scale_exp_k(y, kf, k);
    return y;
#else
    // [-0.3465735912322998046875, 0.3465735912322998046875] : | p - f | <= 2^-27.7265625
    // coefficients for exp generated by sollya
    // x^0 : +0x8p-3f
    const float native_exp_c0=+1.0000000000e+00f;
    // x^1 : +0x8p-3f
    const float native_exp_c1=+1.0000000000e+00f;
    // x^2 : +0xf.ffffcp-5f
    const float native_exp_c2=+4.9999988079e-01f;
    // x^3 : +0xa.aaa47p-6f
    const float native_exp_c3=+1.6666518152e-01f;
    // x^4 : +0xa.aadccp-8f
    const float native_exp_c4=+4.1669651866e-02f;
    // x^5 : +0x8.91de6p-10f
    const float native_exp_c5=+8.3689447492e-03f;
    // x^6 : +0xb.42872p-13f
    const float native_exp_c6=+1.3744963799e-03f;
    vf_type xx = xrh*xrh;
    vf_type i= impl::poly(xx,
                          native_exp_c5,
                          native_exp_c3,
                          native_exp_c1);
    vf_type j= impl::poly(xx,
                          native_exp_c6,
                          native_exp_c4,
                          native_exp_c2);
    vf_type y= impl::poly(xrh, j, i);
    // y = impl::poly(xrh, y, native_exp_c0);
#if EXP
    y= impl::poly(xrh, y, native_exp_c0);
    y = __scale_exp_k(y, kf, k);
#else
    vf_type yl=y;
    vf_type yee= xrl + xrl*xrh*yl;

    vf_type ye;
    impl::eft_poly(y, ye, xrh, y, native_exp_c0);
    ye += yee;
    vf_type scale = __scale_exp_k(vf_type(0.5f), kf, k);
    impl::eft_poly_si(y, ye, scale, y, ye, vf_type(-0.5f));
    y *= 2;
    y  = y + 2*ye;
    // x small
    y = _T::sel((abs(xrh) < 0x1p-25f) & (kf==0.0), xrh, y);
#endif
    return y;
#endif

}

template <typename _T>
typename cftal::math::test_func<float, _T>::vf_type
cftal::math::test_func<float, _T>::
func(arg_t<vf_type> d)
{
#if EXP
    vf_type res=func_k(d);
    using fc= func_constants<float>;
    const vf_type exp_hi_inf= fc::exp_hi_inf();
    const vf_type exp_lo_zero= fc::exp_lo_zero();
    res = _T::sel(d <= exp_lo_zero, 0.0, res);
    res = _T::sel(d >= exp_hi_inf, _T::pinf(), res);
    res = _T::sel(d == 0.0, 1.0, res);
    res = _T::sel(d == 1.0, M_E, res);
    return res;
#else
    vf_type res = func_k(d);
    using fc= func_constants<float>;
    const vf_type expm1_hi_inf= fc::expm1_hi_inf();
    const vf_type expm1_lo_minus_one= fc::expm1_lo_minus_one();
    res = _T::sel(d <= expm1_lo_minus_one, -1.0, res);
    res = _T::sel(d >= expm1_hi_inf, _T::pinf(), res);
    res = _T::sel(d == 0.0, 0.0, res);
    res = _T::sel(d == 1.0, M_E-1.0, res);
    return res;
#endif
}


int main(int argc, char** argv)
{
    using namespace cftal::test;
    std::cout << std::setprecision(18) << std::scientific;
    std::cerr << std::setprecision(18) << std::scientific;
    const int ulp=4;
    const int _N=16;
    bool rc=true;
    bool speed_only=false;
    std::size_t cnt=update_cnt(0x8000);
    if ((argc > 1) && (std::string(argv[1]) == "--speed")) {
        speed_only=true;
        cnt *=8;
    }
    using ftype = float;

    // func_domain<double> d=std::make_pair(0.0,
    //                                     std::numeric_limits< double >::max());
    func_domain<ftype> d=std::make_pair(-std::numeric_limits<ftype>::max(),
                                         std::numeric_limits<ftype>::max());
#if EXP>0
    d=std::make_pair(-104.0f, 89.0f);
#else
    d=std::make_pair(-18.0f, 89.0f);
#endif
    exec_stats st(_N);
    auto us=std::make_shared<ulp_stats>();
    rc &= of_fp_func_up_to<
        ftype, _N, check_func<ftype> >::v(st, d, speed_only,
                                          cmp_ulp<ftype>(ulp, us),
                                          cnt);
    d=std::make_pair(-0x1p-4, 0x1p-4);
    rc &= of_fp_func_up_to<
        ftype, _N, check_func<ftype> >::v(st, d, speed_only,
                                           cmp_ulp<ftype>(ulp, us),
                                           cnt>>2);
    std::cout << "ulps: "
              << std::fixed << std::setprecision(4) << *us << std::endl;
    std::cout << st << std::endl;
    return (rc == true) ? 0 : 1;
}
