//
// Copyright Axel Zeuner 2010-2021. Use, modification and
// distribution is subject to the Boost Software License, Version
// 1.0. (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#if !defined(__CFTAL_TEST_CHECK_EXPM1_H__)
#define __CFTAL_TEST_CHECK_EXPM1_H__ 1

#include <cftal/config.h>
#include <cftal/vec.h>
#include <cftal/test/call_mpfr.h>
#include <cftal/math/horner.h>
#include <cmath>

namespace cftal {
    namespace test {

        template <typename _T>
        struct check_expm1 {
            template <std::size_t _N>
            static
            vec<_T, _N>
            v(const vec<_T, _N>& a) {
                return expm1(a);
            }
            static
            auto
            r(const _T& a) {
                std::pair<_T, _T> i;
                _T v=call_mpfr::func(a, mpfr_expm1, &i);
                return std::make_tuple(v, i.first, i.second);
                // return call_mpfr::func(a, mpfr_expm1)
            }
            
            static
            float __expm1(float x);
            
            static
            double __expm1(double x) {
                return std::expm1(x);
            }
            
            static
            _T
            s(const _T& a) {
                // return std::expm1(a);
                return __expm1(a);
            }
            static
            const char* fname() { return "expm1"; }
        };

    }
}

template <typename _T>
inline
float
cftal::test::check_expm1<_T>::__expm1(float x)
{
#if 0
    return ::expm1f(x);
#else
    float xa=std::fabs(x);
    if (xa > 1.0f)
        return std::exp(x)-1.0f;
    if (xa < 0x1p-24f)
        return x;
    // [-1, 1] : | p - f | <= 2^-31.3203125
    // coefficients for expm1 generated by sollya
    // x^1 : +0x8p-3f
    constexpr
    const float expm11=+1.0000000000e+00f;
    // x^2 : +0x8p-4f
    constexpr
    const float expm12=+5.0000000000e-01f;
    // x^3 : +0xa.aaaabp-6f
    constexpr
    const float expm13=+1.6666667163e-01f;
    // x^4 : +0xa.aaaacp-8f
    constexpr
    const float expm14=+4.1666671634e-02f;
    // x^5 : +0x8.88875p-10f
    constexpr
    const float expm15=+8.3333151415e-03f;
    // x^6 : +0xb.60a81p-13f
    constexpr
    const float expm16=+1.3888628455e-03f;
    // x^7 : +0xd.00e14p-16f
    constexpr
    const float expm17=+1.9841670291e-04f;
    // x^8 : +0xd.0621cp-19f
    constexpr
    const float expm18=+2.4841217964e-05f;
    // x^9 : +0xb.b3acp-22f
    constexpr
    const float expm19=+2.7899368433e-06f;
    // x^10 : +0x8.b091ep-25f
    constexpr
    const float expm110=+2.5897401201e-07f;
    static_assert(expm11 == 1.0, "constraint violated");
    static_cast<void>(expm11);
    
    const float c[]={
        expm110, expm19, expm18, expm17, expm16, 
        expm15, expm14, expm13, expm12
    };    
    float x2=x*x;
    float e= x + math::horner2(x, x2, c) * x2;
    return e;
#endif
}


// local variables:
// mode: c++
// end:

#endif
