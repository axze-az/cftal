\documentclass[10pt,a4paper,wide]{article}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage{color}
\usepackage{listings}
\usepackage[bookmarks=true,hidelinks]{hyperref}
\numberwithin{equation}{subsection}


\lstset{
  % change this to 11 later
  language={C++},
  basicstyle=\footnotesize,
  keywordstyle=\bfseries\color{black},
  identifierstyle=\color{black}
}

\begin{document}
\title{cftal - yet another short vector library}
\author{axel zeuner}
\maketitle

\tableofcontents

\section{Introduction}
\label{sec:introduction}

The cftal library contains a C++11(+) short vector implementation. A
short vector is vector with up to 64 elements.

The design principles of the short vector library are
templates, recursion and specialization:

\begin{itemize}
\item A vector of length $N$ contains two vectors of length $N/2$
  (this also forces the library to vector lengths of powers of 2).
\item The vectors of length $1$ are specialized
\item Vectors with the same length as hardware vector implementation
  for different system may be specialized.
\item Partial and full specialization may be used to allow the
  selection of special intrinsic functions for hardware vector
  implementations
\item Expression templates are used for operations on the short
v  vectors. This allows the filtering for special operation patterns,
  for instance generation of fused multiply add intrinsics from
  expressions like $ c= a* b + c $. More optimization are possible,
  but not (yet) implemented.
\end{itemize}

\section{Base components}
\label{sec:base}

All short vectory library code is grouped around the class
\begin{lstlisting}
template <typename _T, std::size_t _N> vec<_T, _N>;
\end{lstlisting}
where $\_T$ is the type and $\_N$ the number of the elements of the
vector.\\
%
A vector of length $N$ may be constructed from
\begin{itemize}
\item a scalar, initializing every vector element to the scalar,
\item two vectors of length $N/2$ with exception of length $1$,
\item an initializer list, initializing excess elements in the
  vector from the last element of the initializer list 
\end{itemize}
A vector may be split into low and high halfes using the functions
\begin{lstlisting}
template <typename _T, std::size_t _N>
const typename vec<_T, _N>::half_type&
low_half(const vec<_T, _N>& v);

template <typename _T, std::size_t _N>
const typename vec<_T, _N>::half_type&
high_half(const vec<_T, _N>& v);
\end{lstlisting}
The most arithmetic operations are defined on all vectors.\\
%
Logical operations on vectors return either a bit mask or a vector of
the same type as the operands. The choice of a bit mask (a vector of
bits) or the same type depends on the machine -- machines with
hardware bit mask should use a bit mask (this means, that on x86 the
type of the result of logical operations depends on the existence of
the 512 bit AVX vector extensions).


\section{Vector Math Library}
\label{sec:vec_math_lib}

This section contains the description of the algorithms used in the
vector math library. The implemented algorithms are the same or
heavily based on the algorithms used in the sun math
library. Therefore the copyright of the sun libm source codes

\begin{verbatim}
/*
 * ====================================================
 * Copyright (C) 2004 by Sun Microsystems, Inc. All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this
 * software is freely granted, provided that this notice
 * is preserved.
 * ====================================================
 */
\end{verbatim}
applies.

Functions for vector length from 1 to 8 are implemented as direct
instantiations of the template code in \texttt{include/cftal/math\_common.h}
using the macros in \texttt{src/vec\_def\_math\_functions.h}.
Functions for greater vector lengths are constructed like
\begin{lstlisting}
template <typename _T, std::size_t _N>
cftal::vec<_T, _N>
cftal::func(const vec<_T, _N>& x)
{
    vec<_T, _N> r= vec<_T, _N>(func(low_half(r)),
                               func(high_half(x)));
    return r;
}
\end{lstlisting}
recursively.\\
%
All polynomial approximations are produced using sollya
(\cite{ChevillardJoldesLauter2010}).


\subsection{List of functions and precisions}
\label{sub_sec:func_list}
The following table contains the list of functions and their measured maximium
deviations against the corresponding functions from the mpfr library. The
column about faithfully rounding describes if faithfully rounding was observed
using the test data set.\\[1cm]
\begin{tabular}{ | p{2.0cm} | p{2.0cm} | p{2.0cm} | p{2.0cm} | p{2.0cm} |}
    \hline \hline
     &
    \multicolumn{2}{| p{4.0cm} |} {\center{binary64}} &
    \multicolumn{2}{| p{4.0cm} |} {\center{binary32}} \\
    \hline
    function & $\Delta$ ulp & (prob.) faithfully &
          $\Delta$ ulp & (prob.) faithfully \\
    \hline \hline
    ldexp & $\pm$ 0 & n/a  & $\pm$ 0 & n/a \\
    \hline
    frexp & $\pm$ 0 & n/a  & $\pm$ 0 & n/a \\
    \hline
    ilogb & $\pm$ 0 & n/a  & $\pm$ 0 & n/a \\
    \hline \hline
    cbrt & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline \hline
    exp & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline
    expm1 & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline
    exp2 & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline
    exp10 & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline
    sinh & $\pm$ 1 & n  & $\pm$ 1 & n \\
    \hline
    cosh & $\pm$ 1 & n  & $\pm$ 1 & n \\
    \hline
    tanh & $\pm$ 1 & n  & $\pm$ 1 & n \\
    \hline \hline
    log & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline
    log1p & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline
    log2 & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline
    log10 & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline \hline
    sin & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline
    cos & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline
    tan & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline \hline
    asin & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline
    acos & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline
    atan & $\pm$ 1 & y  & $\pm$ 1 & y \\
    \hline
    atan2 & $\pm$ 1 & ?  & $\pm$ 1 & ? \\
    \hline \hline
    asinh & $\pm$ 1 & n  & $\pm$ 1 & n \\
    \hline
    acosh & $\pm$ 1 & n  & $\pm$ 1 & n \\
    \hline
    atanh & $\pm$ 1 & n  & $\pm$ 1 & n \\
    \hline \hline
    erf & $\pm$ 1 & y  & $\pm$ 1 & n \\
    \hline

\end{tabular}

double argument identity for exponential functions:
\[
    \begin{aligned}
        (b^x-1)^2 &= b^{2x} - 2b^x + 1 \\
        b^{2x}    &= (b^x-1)^2 + 2b^x - 1 \\
        b^{2x} -1 &= (b^x-1)^2 + 2b^x -2 \\
                  &= (b^x-1)^2 + 2(b^x-1)
    \end{aligned}
\]

argument transformation from $ [a, b] $ into interval $ [-1, 1] $:
\[
    \tilde x = \frac{1}{2} \big[(b-a) x + a +b \big]
\]
\\[10pt]
mapping of the interval $ [0, \infty] $ to the interval $ [-1, 1] $ for
calculation of the error function
\[
    \tilde x = \frac{x-k}{x+k}
\]
with $ k = 3.75 $.

\subsection{basic functions: ldexp, frexp, ilogb}
\label{sub_sec:base_math}
\subsubsection{precision}
The functions have an error of $ \pm 0\, ulp$ compared against their glibc
counterparts

\subsection{exponential functions}
\label{sub_sec:exp}
The function exp(x) calculates $ e^x $.

\subsubsection{precision}
The functions have an error of $ \pm 1\, ulp$.

\subsubsection{implementation}
\begin{itemize}
\item Argument reduction

    Reduce $x$ to $r$ so that $ |r| \le \frac{1}{2} log(2) $
    \begin{equation}
        x = k \times log(2) + r, \; |r| \le \frac{1}{2} log(2)
    \end{equation}
    $r$ is split into two values for calculation purposes
    \[
       \begin{aligned}
       r_h &= x - k \times LN2_{HI} \\
       r_l &= k \times LN2_{LO} \\
       r &= r_h - r_l
       \end{aligned}
    \]
    where $LN2_{HI}$ and $LN2_{LO}$ are Cody and Waite constants for $log(2)$.

\item Approximation of $e^r$ by a rational function on the interval
    $[0,\,\frac{1}{2}log(2)]$:

    as

    \begin{equation}
        \begin{aligned}
            e^{r} &= 1 + r + \frac{r^2}{2} + \frac{r^3}{6} + \dots \\
                  &\approx  1 + \frac {2r} {2 -r + r^2 P(r^2)} \\
        \end{aligned}
    \end{equation}

    To obtain higher precision the last equation is rewritten as
    \begin{equation}
        e^{r} \approx  1 + r + \frac{r [r -r^2 P(r^2)]} {2-[r-r^2P(r^2)]}
    \end{equation}

    Furthermore a correction term
    \[
        c = (r_h - r) - r_l
    \]
    is calculated.

    Using the taylor series of $e^{r+c}-1$ for $c \ll r$ and and truncating
    higher order terms
    \begin{equation}
        \label{equ:expm1-taylor}
        \begin{aligned}
            e^{r+c}-1 &= (e^r-1) + e^r\,c  + \frac{e^r c^2}{2} + \dots \\
                      &= (e^r-1) + e^r\,c  + \dots \\
                      &= (e^r-1) + (1+r+\frac{r^2}{2}+\dots)\,c + \dots \\
                      &= (e^r-1) + (c + r\,c + \dots) + \dots \\
                      &\approx (e^r-1) + c + r\,c
        \end{aligned}
    \end{equation}
    $e^{r+c}$ is calculated as
    \begin{equation}
        \begin{aligned}
            s &= \frac{r [r -r^2 P(r^2)]} {2-[r-r^2P(r^2)]} \\
            s &= s + r*c \\
            s &= s + c \\
            s &= s + r \\
            e^{r+c} &= s + 1
        \end{aligned}
    \end{equation}

    The order of the minimax polynomial $P(r^2)$ is 10 for double precision.

\item The function value of the reduced argument is scaled back using
    \begin{equation}
        e^x = 2^k \times e^r
    \end{equation}
    to obtain the result.

\end{itemize}


\subsection{expm1}
\label{sub_sec:expm1}
The function expm1(x) calculates $ e^x-1 $.

\subsubsection{precision}
The functions have an error of $ \pm 1\, ulp$.

\subsubsection{implementation}
\begin{itemize}
\item Argument reduction

    Reduce $x$ to $r$ so that $ |r| \le \frac{1}{2} log(2) $
    \begin{equation}
        x = k \times log(2) + r, \; |r| \le \frac{1}{2} log(2)
    \end{equation}
    $r$ is split into two values for calculation purposes
    \[
       \begin{aligned}
       r_h &= x - k \times LN2_{HI} \\
       r_l &= k \times LN2_{LO} \\
       r &= r_h - r_l
       \end{aligned}
    \]
    where $LN2_{HI}$ and $LN2_{LO}$ are Cody and Waite constants for $log(2)$.
    Furthermore a correction term
    \[
        c = (r_h - r) - r_l
    \]
    is calculated.

\item Approximation of $e^r-1$ by a special rational function on the interval
    $[0,\,\frac{1}{2}log(2)]$:
    \[
        r \frac{e^{r}+1}{e^{r}-1} =
        2+\frac{r^2}{6}-\frac{r^4}{360}+\cdots
    \]

\end{itemize}

\subsection{exp2}
The function exp2(x) calculates $ 2^x $.

\subsection{pow}
The function pow(x,y) calculates $ x^y $.

\subsubsection{precision}
The functions have an error of $ \pm x\, ulp$.

\subsubsection{implementation}
\begin{itemize}
\item argument reduction
    \begin{equation}
        \begin{aligned}
        x^y &= (2^{k_x} \times m_x) ^ {2^{k_y} \times m_y} \\
        log(x^y) &= y*log(x) \\
                 &= (2^{k_y} log(m_x) + log(2) k_x 2^{k_y}) m_y \\
                 &= (log(m_x) + log(2) k_x) 2^{k_y} m_y \\
        \end{aligned}
    \end{equation}
\end{itemize}

\subsection{cbrt}

\subsection{asinh}
\label{sub_sec:asin}
The function asin(x) calculates $ asinh(x) $.

\subsubsection{precision}
The functions have an error of $ \pm 2\, ulp$.

\subsubsection{implementation}
\begin{itemize}
\item Argument reduction
    \[
        \begin{aligned}
          asinh(x) &= log(x+\sqrt{1+x^2}) \\
                   &= log(x+\sqrt{1-x}\sqrt{1+x}) \\
          asinh(u) + asinh(v) &= asinh(u\sqrt{1+v^2} + v\sqrt{1+u^2}) \\
          asinh(x) + asinh(x) &= asinh(x\sqrt{1+x^2} + x\sqrt{1+x^2}) \\
                              &= asinh(2\,x\sqrt{1+x^2}) \\
          x &= 2^k\times r
        \end{aligned}
    \]
\end{itemize}

\bibliographystyle{plain}
\bibliography{cftal-doc}

\end{document}

